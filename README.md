# slot_combination
### 主要特点：
    1. 运行速度非常快
	2. 支持正则语法
	3. 支持规则模糊匹配，句式归一化，带范化能力
	4. 支持简单的自动生成规则功能
	5. 基于词库的方式，便于复用， 逻辑上更清晰
	
####  例子：
   
    新的规则： 
     atom 听 = 听|播放
     atom 量词 = 一首?|一个
     atom 歌曲对象 = 歌曲|歌
     export r1 = [{听}, <{量词}？, {.歌手名}？>, {.歌曲名}|{歌曲对象} ]  => {}

	一条规则能覆盖如下的:   听下刘德华的歌
	                     听下刘德华的忘情水
						 听一首刘德华的歌曲
						 听下刘德华的一首歌曲
						 听一下忘情水
						 ...
	
	
	
### 实验： 
   用了dui的两个线上领域测试： 1. 计算器领域， 2. 古诗领域， （重写覆盖了计算器的大部分规则， 古诗领域全部规则）
   dui的测试数据， 解析结果中解析正确性没有问题， 速度平均小于0.5ms左右
   计算器的测试集合包含了之前超时的测试集合
   
   
### 实现思路：
1. 所有的关键词都有类型， 或者说所有词都属于词表（一个词可以属于多个类型）
2. 把规则编译成一个前缀树T的结构，便于检索 （预处理过程）
3. 用AC状态机找出所有的词的列表L
4. 列表L上搜索所有词的不交叉组合，选出所有满足规则的可能集合，注: 用第2步的数据结构能让每次搜索时间复杂度为O(1)

#### 索引结构构造：
[{听}, <{量词}？, {歌手名}？>, {歌曲名}|{歌曲对象} ]  将会扩展为 听_量词_歌手名_歌曲名   听_歌手名_歌曲名   听_量词_歌曲名 , 听_量词_歌曲对象,  听_歌手名_量词_歌曲名, ...
这些扩展的规则可以build成一个前缀树的结构， 树中的节点可以设定条件， 比如限定每个槽位长度不大于K， 只要在匹配的时候检查下这个条件是否满足即可

#### 搜索过程：
比如 听一首刘德华的歌曲， 听：听， （一首， 一），量词， 刘德华： 歌手名， （歌，歌曲）： 对象
搜索过程遍历所有可能性  
  step1： 听， 在树结构中，继续
  step2： 听_量词, 在树结构中，继续
  ...

检索过程中，不相关的字会被跳过， 以及不符合语法的不会被选中， 解析时间复杂度正比于搜索步数


#### 时间复杂性分析：
 假设query长度为L， 解析出的候选词集合大小为N
- 步骤1,2, 不消耗预测时间
- 步骤3的近似复杂度是L， 最差复杂度是L^2, 考虑大部分到L<=30， 这个时间可以忽略不计
- 步骤4的时间正比于搜索次数， 搜索的最坏时间复杂度为： 2^N, 当N为20时，最多需要搜索1048576次， 保守的估计C++也能控制在200ms以内
- 事实上需要的搜索次数要远远小于2^N

