
#  解析引擎实现
   
### 实现思路：
一句话是由词汇按照一定顺序组成的， 匹配过程就是检索query中的词汇组合，找到其中能符合期望规则集合的组合，即是一个候选匹配，在众多的候选匹配中再选出一个或多个作为最终输出结果
大致有如下几个步骤：
预处理过程：
1. 提取出规则中的词表及atom变量，构建AC状态机, (用于找出所有词汇)
2. 把规则扩展成完整的词标签表示，并编译成一个词标签的前缀树**T**，(用于检索)

query匹配过程：
3. 用AC状态机找出query中所有能匹配到的词, 设为列表**L**
4. 逐个匹配所有的plus规则和带特殊后处理的变量, 把匹配到的部分作为新的词汇插入**L**中
5. 在列表**L**上搜索所有词的不交叉组合，找到所有满足规则的候选集合, (可以用常见的深度优先搜索， 配合一些剪枝策略)

后处理过程：
6. 对候选集合做过滤，
7. 按照一定策略从集合中选出一个最佳匹配， 或者多个匹配
8. 提取出槽位，后处理格式变换等，按照格式输出最后的结果

#### AC状态机的构造：
AC状态机是一种高效的多模式字符串匹配算法, 实现中直接使用了python的库pyahocorasick, 相关使用见ac.py文件
比如：
atom tag_播放 = 播放|放|播
那么 “播放歌曲” 可以匹配到三个词汇：("播放", ["tag_播放"], 0, 2),  ("播", ["tag_播放"], 0, 1),  ("放", ["tag_播放"], 1, 2)，
其中tag_播放是词汇的标签(类型), 一个词可以有多个标签，所以这里是list

#### 规则索引结构构造：
`[{听}, <{量词}？, {歌手名}？>, {歌曲名}|{歌曲对象} ]`规则可以匹配到很多句子，用词标签表示成如下：
    听_量词_歌手名_歌曲名,
    听_歌手名_歌曲名，
    听_量词_歌曲名，
    听_量词_歌曲对象，
    听_歌手名_量词_歌曲名，
     ， ...
这些句子就是词标签的扩展，这些扩展就像字典一样，搜索时只要看选出的词组合是否在字典里，就能判断是否是与规则匹配。
把所有export规则的词标签扩展构建成一个前缀树的结构，如图： ![Trie](../images/trie.jpg)


这样在搜索时可以快速判定是否是有效的匹配路径，当匹配到叶子节点即是完整匹配, 对应的规则就是候选规则。 特别的**树中的节点可以设定逻辑条件**，搜索的时候通过检查条件是否成立来控制搜索过程（比如限定某个槽位长度不大于K），这样可以实现强于正则语法的功能。 
注：正则语法中的 `+和*`带有循环，比较难放入树的结构中去，而且这两个语法可能会让搜索空间指数提升，所以针对这两个语法做了特殊预处理， 实现中采用了贪心匹配。

#### 搜索过程：
搜索的过程即是匹配前缀树的过程。 
比如 **听一首刘德华的歌曲**解析的词表为： 
```
(听：听)，(一首，量词), (一，量词),  (刘德华：歌手名)， (歌曲： 对象), (歌，对象)
```
搜索过程遍历所有可能性, 比如深度优先搜索：
  step1： 听， 在树结构中，继续
  step2： 听_量词, 在树结构中，继续
  step3： 听_量词_歌手名, 在树结构中，继续
  step4： 听_量词_歌手名_对象(歌曲), 是叶子节点，完整匹配，加入候选集, 同时搜索回溯
  step5： 听_量词_歌手名_对象(歌), 在树结构中，完整匹配，加入候选集
  ...


检索过程中只在词的列表L上进行，不相关的字会被跳过，这样就实现了模糊匹配； 整体上解析时间复杂度正比于搜索步数, 当句子不是很长，词汇表不是很大的情况下是非常快的; 当然为了进一步提高性能会有一些剪枝策略。 


#### 时间复杂性分析：
 *假设query长度为L， 解析出的候选词集合大小为N*
- 步骤1,2, 预处理过程，不消耗预测时间
- 步骤3的近似复杂度是L， 最差复杂度是L^2, 考虑大部分到L<=30， 这个时间可以忽略不计
- 步骤4的时间正比于搜索次数， 搜索的最坏时间复杂度为： 2^N, 当N为20时，最多需要搜索1048576次， 保守的估计C++也能控制在200ms以内
- 时间与规则数量没有直接线性关系，因为不需要对规则遍历
- **事实上需要的搜索次数要远远小于2^N**
   1. 对于30个字以内的句子，大部分领域不会有这么多候选词； 20个字，每个词平均2个字，那只有10个词， 当N <= 10时， 最多1024次搜索，非常快; 当然这里需要考虑领域内词之间的重叠度，大部分领域重叠度不会太大
   2. 规则会对搜索过程中做剪枝，非法的组合会停止;  比如计算器领域内词很多， 一加一加一加一加一... , 虽然词多完全不影响速度
   3. 搜索过程中会限定词之间不能有重叠， 词之间的最大间隔不超过一定距离， 相差太远的词的组合错误不会出现，这个会大大减小搜索空间

###  程序结构
 - builtin.py 内置关键词，特殊符号等
 - util.py  一些工具函数
 - items.py 一些辅助性类定义
 - stream.py stream构造类，用于文法解析
 - config.py 配置文件
 - syntax.md 语法说明文件
 - syntax_check.py  语法检查辅助类
 - ac.py  AC自动机
 - tokens.py  把lex文件解析成tokens
 - ast.py  解析成语法树
 - parse.py  把语法树构建成Trie树，及后处理信息
 - search.py  搜索出所有可以匹配的规则
 - select.py  候选集筛选策略
 - app.py 运行入口文件
 - post_register.py 后处理函数库注册类
 - post_libs  定义后处理函数的目录